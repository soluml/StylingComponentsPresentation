<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>Stylin’ Components</title>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/black.css" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css" />
    <style>
      body {
        font-weight: 300;
      }

      #introslide {
        width: 100%;
        height: 100%;
        top: 0 !important;
      }
      #intro {
        border: 1.8vmax solid transparent;
        box-sizing: border-box;
        margin: auto;
        left: 50%;
        position: absolute;
        text-align: left;
        top: 50%;
        transform: translate(-50%, -50%);
        white-space: nowrap;
        width: 70%;
      }

      #intro:after {
        border: inherit;
        box-sizing: inherit;
        content: "";
        display: block;
        padding-bottom: 100%;
      }

      #intro span {
        font-size: 100%;
        position: absolute;
        left: 50%;
        top: 50%;
        text-align: center;
        font-weight: 900;
        transform: translate(-50%, -35%);
        -webkit-text-stroke: 2px rgba(255, 255, 255, 0.8);
        color: var(--r-background-color);
      }

      #intro small {
        display: block;
        font-size: 0.75em;
        line-height: 1;
      }

      #intro svg text {
        bottom: 0;
        fill: #fff;
        display: block;
        font-size: 0.0575rem;
        letter-spacing: 0.035em;
        text-transform: none;
        transform: translateY(2em);
        width: 100%;
      }

      #intro svg {
        opacity: 0.6;
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        width: 100%;
      }

      .classCodeTitle {
        text-align: center !important;
        text-shadow: none;
      }
      .cssinlineeditor {
        align-items: center;
        display: grid;
        grid-template-columns: 1.25fr 1fr;
      }

      h4 {
        text-align: left;
      }

      h4 + ul {
        display: block;
        margin-bottom: 1em !important;
        text-align: left;
        width: 100%;
      }

      span[class^="hljs-selector"][data-spec0]:not(:has([data-spec0])) {
        align-items: baseline;
        display: inline-flex;
        gap: 0.25em;
      }

      span[class^="hljs-selector"][data-spec0]:not(:has([data-spec0]))::after {
        content: "(" attr(data-spec1) "," attr(data-spec2) "," attr(data-spec3)
          ")";
        font-size: 0.5em;
        font-weight: 400;
        pointer-events: none;
        user-select: none;
      }

      .cssapproach {
        align-items: center;
        color: rgba(255, 0, 0, 0.85);
        display: flex;
        font-weight: 400;
        gap: 0.1em;
        font-size: 3em;
        position: absolute;
        right: 100%;
        bottom: 0;
        transform: translate(-20%, 12%);
        text-align: right;
      }

      .cssapproach small {
        font-size: 0.31em;
        font-weight: 300;
        line-height: 1;
        padding-top: 0.25em;
      }

      .iconlist.iconlist {
        font-size: 0.7em;
        list-style: none;
      }

      .iconlist ::before {
        background-repeat: no-repeat;
        background-size: contain;
        content: "";
        display: inline-block;
        vertical-align: middle;
        height: 1em;
        width: 1em;
        margin: -0.25em 0 0 -1em;
      }

      .sac::before {
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='white' d='M18 4v16h-4v-16h4zM14 28h4v-4h-4v4z'%3E%3C/path%3E%3C/svg%3E");
      }
      .sac.bad::before {
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='red' d='M18 4v16h-4v-16h4zM14 28h4v-4h-4v4z'%3E%3C/path%3E%3C/svg%3E");
      }
      .sac.good::before {
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='green' d='M18 4v16h-4v-16h4zM14 28h4v-4h-4v4z'%3E%3C/path%3E%3C/svg%3E");
      }

      .man::before {
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='white' d='M14.586 20.243l2.828 2.828-2.828 2.828-2.828-2.828-2.828 2.828-2.828-2.828 2.828-2.828-2.828-2.828 2.828-2.828 2.828 2.828 11.313-11.315 2.828 2.828-11.313 11.315z'%3E%3C/path%3E%3C/svg%3E");
      }
      .man.bad::before {
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='red' d='M14.586 20.243l2.828 2.828-2.828 2.828-2.828-2.828-2.828 2.828-2.828-2.828 2.828-2.828-2.828-2.828 2.828-2.828 2.828 2.828 11.313-11.315 2.828 2.828-11.313 11.315z'%3E%3C/path%3E%3C/svg%3E");
      }
      .man.good::before {
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='green' d='M14.586 20.243l2.828 2.828-2.828 2.828-2.828-2.828-2.828 2.828-2.828-2.828 2.828-2.828-2.828-2.828 2.828-2.828 2.828 2.828 11.313-11.315 2.828 2.828-11.313 11.315z'%3E%3C/path%3E%3C/svg%3E");
      }

      .flex::before {
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='white' d='M28 12v12h-12v-4h8v-4h-8v-4h12zM8 16v-4h8v-4h-12v12h12v-4h-8z'%3E%3C/path%3E%3C/svg%3E");
      }
      .flex.bad::before {
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='red' d='M28 12v12h-12v-4h8v-4h-8v-4h12zM8 16v-4h8v-4h-12v12h12v-4h-8z'%3E%3C/path%3E%3C/svg%3E");
      }
      .flex.good::before {
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='green' d='M28 12v12h-12v-4h8v-4h-8v-4h12zM8 16v-4h8v-4h-12v12h12v-4h-8z'%3E%3C/path%3E%3C/svg%3E");
      }

      .dx::before {
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='white' d='M26 12v16h-4v-16h4zM6 20h4v-16h-4v16zM16 20h4v-4h-4v4z'%3E%3C/path%3E%3C/svg%3E");
      }
      .dx.bad::before {
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='red' d='M26 12v16h-4v-16h4zM6 20h4v-16h-4v16zM16 20h4v-4h-4v4z'%3E%3C/path%3E%3C/svg%3E");
      }
      .dx.good::before {
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='green' d='M26 12v16h-4v-16h4zM6 20h4v-16h-4v16zM16 20h4v-4h-4v4z'%3E%3C/path%3E%3C/svg%3E");
      }

      .size::before {
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='white' d='M28 13l-12 12-12-12 6-6 6 6.173 6-6.173 6 6z'%3E%3C/path%3E%3C/svg%3E");
      }
      .size.bad::before {
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='red' d='M28 13l-12 12-12-12 6-6 6 6.173 6-6.173 6 6z'%3E%3C/path%3E%3C/svg%3E");
      }
      .size.good::before {
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='green' d='M28 13l-12 12-12-12 6-6 6 6.173 6-6.173 6 6z'%3E%3C/path%3E%3C/svg%3E");
      }
    </style>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section id="introslide">
          <h1 id="intro">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
              <path
                fill="#eee"
                d="M2.667 8l13.94-8 13.94 8 0.12 15.933-14.060 8.067-13.94-8zM5.451 11.308v6.343l4.46 2.48v4.688l5.296 3.061v-11.029zM27.769 11.308l-9.756 5.543v11.029l5.296-3.061v-4.685l4.46-2.481zM6.845 8.801l9.737 5.525 9.76-5.573-5.161-2.929-4.547 2.593-4.573-2.624z"
              ></path>
              <text x="5.1" y="31.6">
                github.com/soluml/StylingComponentsPresentation
              </text>
            </svg>
            <span>
              <small>Stylin’</small>
              Components
            </span>
          </h1>
        </section>
        <section>
          <img
            alt="CSS is awesome"
            src="/css-is-awesome.jpg"
            style="height: 60vh; aspect-ratio: 1088/826; opacity: 0.8"
          />
        </section>
        <section>
          <h2>What are we covering?</h2>
          <ol
            style="
              display: block;
              width: 30ch;
              margin: auto;
              position: relative;
            "
          >
            <li class="fragment">Relevant CSS Concepts</li>
            <li class="fragment">Popular CSS Conventions</li>
            <li class="fragment">
              Popular CSS Frameworks / Tooling
              <div class="fragment cssapproach">
                <small>CSS Methodology</small> {
              </div>
            </li>
          </ol>
        </section>
        <section>
          <h2>Considerations when <br />stylin’ components:</h2>
          <ol>
            <li class="fragment">Manages <u>Specificity</u> and the Cascade</li>
            <li class="fragment">Highly Maintainable (Updating/Refactoring)</li>
            <li class="fragment">Flexibility / Usability</li>
            <li class="fragment">
              Good <abbr title="Developer Experience">DX</abbr> [Inputs]
              <small style="vertical-align: middle">
                (i.e. Style Colocation)
              </small>
            </li>
            <li class="fragment">Low Bloat / Small Size [Outputs]</li>
          </ol>
        </section>
        <section>
          <section>
            <h2>Concepts</h2>
          </section>
          <section>
            <h3>Specificity</h3>
            <blockquote style="font-size: 0.75em">
              Specificity is the means by which browsers decide which CSS
              property values are the most relevant to an element and,
              therefore, will be applied.
            </blockquote>
            <hr />
            <div class="cssinlineeditor" id="specificity">
              <div id="example" class="example">I'm an example! √</div>
            </div>
          </section>
          <section>
            <h3>:where/:is</h3>
            <blockquote style="font-size: 0.75em">
              <code>:where</code> and <code>:is</code> are specificity
              manipulating pseudo classes. Both match the containing elements.
              However, <code>:where</code> eliminates the specificity of it's
              contained selector whereas <code>:is</code> takes the maximum
              selector value and adds it to the base selector.
            </blockquote>
            <hr />
            <div class="cssinlineeditor" id="specificity2">
              <div id="example2" class="example2">I'm an example 2! √</div>
            </div>
          </section>
          <section>
            <h3>Cascade Layers</h3>
            <blockquote style="font-size: 0.75em">
              Cascade <code>@layer</code>'s are a recent browser addition that
              give you the ability to define layers of specificity for your
              selectors. The order of precedence for layers is the order in
              which layers are declared, named or not, and lower than the styles
              declared outside of a layer.
            </blockquote>
            <hr />
            <div class="cssinlineeditor" id="specificity3">
              <div id="example3" class="example3">I'm an example 3! √</div>
            </div>
          </section>
          <section>
            <h3>Shadow DOM</h3>
            <blockquote style="font-size: 0.55em">
              The Shadow DOM allows hidden DOM trees to be attached to elements
              in the regular DOM tree. Within these hidden DOM trees we can
              encapsulate our styles. We can also choose to ingest outside
              styles via the <code>::part</code> pseudo-element which represents
              an element within a shadow tree that has a matching part
              attribute.
            </blockquote>
            <hr />
            <div class="cssinlineeditor" id="specificity4">
              <div>
                <div id="example4" class="example4">I'm an example 4! √</div>
              </div>
            </div>
          </section>
        </section>
        <section>
          <section>
            <h2>CSS Methodologies</h2>
          </section>
          <section>
            <h3>Inline</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr">
              <pre><code class="html">&lt;!-- HTML --&gt;
&lt;div style="color:blue;"&gt;&lt;/div&gt;</code></pre>
              <pre><code class="js">// React
const styles = {
  color: 'blue',
};
&lt;div style={styles} /&gt;
</code></pre>
            </div>
          </section>
          <section>
            <h4>Inline Convention:</h4>
            <ul>
              <li>
                Inline conventions make use of the style attribute on HTML
                elements:
                <pre
                  style="display: inline"
                ><code class="html" style="display:inline;">&lt;div style="color:blue;"&gt;</code></pre>
              </li>
            </ul>
          </section>
          <section>
            <h4>Inline Tooling:</h4>
            <ul style="font-size: 0.7em">
              <li>
                Inline tools construct a JavaScript object and render the
                contents into the style attribute:
              </li>
              <li>
                CSS-in-JS, as a concept, was
                <a href="https://speakerdeck.com/vjeux/react-css-in-js"
                  >born as inline tooling</a
                >.
              </li>
              <li>
                Early CSS-in-JS tooling, like
                <a href="https://github.com/FormidableLabs/radium">Radium</a>,
                leveraged Inline styles.
              </li>
              <li>
                It's common for Inline tooling to shim features like Media
                Queries and Pseudo Classes with JavaScript.
              </li>
            </ul>
            <div style="display: grid; grid-template-columns: 1fr 1fr">
              <pre><code class="js">// React
var styles = {
  background: 'blue',
  border: 0,
  color: 'white',
  // No pseudo's... :(
};</code></pre>
              <pre><code class="js">// Radium
var styles = {
  base: {
    background: 'blue',
    border: 0,
    color: 'white',
    ':hover': { // or :focus/:active
      backgroundColor: 'red'
    },
  },
};</code></pre>
            </div>
          </section>
          <section>
            <h4>Inline as an Input:</h4>
            <ul class="iconlist">
              <li class="man good">
                Extremely high maintainability! Easy to update AND refactor!
              </li>
              <li class="dx">
                DX is decent. Easy to locate contextual styles. Can be tough to
                use with IDE tooling. Can be typed with TypeScript!
              </li>
            </ul>
            <h4>Inline as an Output:</h4>
            <ul class="iconlist">
              <li class="sac good">
                High specificity means Inline Styles are essentially immune to
                specificity and cascade issues!
              </li>
              <li class="flex">
                Hard to augment with external libraries but won't interfere with
                others.
              </li>
              <li class="flex bad">
                No support for @rules, pseudo-elements/classes!!
              </li>
              <li class="size bad">
                Only the CSS neccessary to style the element is used! However,
                it bloats the DOM which is often uncached and no tooling
                optimizations can be performed.
              </li>
            </ul>
          </section>
          <section>
            <h3>Semantic / Nested</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr">
              <pre><code class="css">/* Sass */
[role=tab] {
  background: #fff;

  &amp;[aria-selected=true] {
    color: red;
  }
}</code></pre>
              <pre><code class="css">/* ...or natively coming
  soon to a browser near you! */
div {
  background: #fff;

  &amp; .red {
    color: blue;
  }
}</code></pre>
            </div>
          </section>
          <section>
            <h4>Semantic / Nested Convention:</h4>
            <ul style="font-size: 0.7em">
              <li>
                Selectors should
                <a
                  href="https://alistapart.com/article/meaningful-css-style-like-you-mean-it/"
                  >meaningfully</a
                >
                reflect your DOM, often without using classes.
              </li>
              <li>
                Nested conventions are essentially the same but describe the
                DOM's shape and use any/all selectors.
              </li>
              <li>
                Requires a solid understanding of HTML semantics, markup,
                <a
                  href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA"
                  >ARIA</a
                >, and
                <a
                  href="https://developer.mozilla.org/en-US/docs/Web/HTML/Microdata"
                  >Microdata</a
                >.
              </li>
              <pre><code class="css">/* Ooooh.. semantic! */
[role=tab][aria-selected=true] {
  background: #fff;
}

[itemscope][itemtype$="SoftwareApplication"] {
  display: block;
}

form > p {
  font-weight: bold;
}

/* Ooooh.. lazy! */
div > .class > p {
  text-align: center;
}</code></pre>
            </ul>
          </section>
          <section>
            <h4>Nested Tooling:</h4>
            <ul style="font-size: 0.7em">
              <li>
                Currently not possible natively in browsers (outside of Chrome
                with a feature flag) so we have to use tools.
              </li>
              <li>
                Nested was popularized by Preprocessors, most notably Sass!
              </li>
              <li>
                Can also be handled with Postprocessors like
                <a href="https://github.com/postcss/postcss-nested">PostCSS</a>.
              </li>
            </ul>
          </section>
          <section>
            <h4>Semantic or Nested as an Input:</h4>
            <ul class="iconlist">
              <li class="man bad">
                Difficult to maintain outside of the Shadow DOM (where this is a
                great candidate).
              </li>
              <li class="dx">
                No tooling required but tooling makes the selector salad a bit
                easier to digest. If pursuing a semantic approach it requires
                all devs touching the CSS to have deep knowledge of HTML.
              </li>
            </ul>
            <h4>Semantic or Nested as an Output:</h4>
            <ul class="iconlist">
              <li class="sac">
                Requires deep nesting / specificity to ensure there are no
                conflicts. Somewhat alleviated when pursuing a semantic
                approach.
              </li>
              <li class="flex bad">
                Hard to mix with external libraries (without Cascade Layers).
              </li>
              <li class="size good">
                If done perfectly, there's minimal to no class/style attributes
                used in your markup!
              </li>
              <li class="size bad">
                CSS bloats as structures are difficult to share. New components
                require all new structures.
              </li>
            </ul>
          </section>
          <section>
            <h3>Naming</h3>
            <pre><code class="css">/* BEM Methodology */
.button {
  border: 1px solid #D5D5D5;
  font: 700 13px/18px Helvetica, arial;
}

.button__label {
  text-transform: uppercase;
}

.button--state-success {
  color: #FFF;
  border-color: #4A993E;
}</code></pre>
          </section>
          <section>
            <h4>Naming Convention(s):</h4>
            <ul style="font-size: 0.7em">
              <li>
                These types of conventions enforce strict authoring guidelines
                to maintain specificity, typically by exclusively authoring your
                styles with class selectors and pseudo class selectors (i.e. -
                <pre
                  style="display: inline"
                ><code class="css" style="display:inline;">.button:hover</code></pre>
                ).
              </li>
              <li>
                Pseudo-class specificity can be negated with
                <code>:where</code> (
                <pre
                  style="display: inline"
                ><code class="css" style="display:inline;">.button:where(:hover)</code></pre>
                ).
              </li>
              <li>
                The classes have no semantic value and no opinions on the
                markup.
              </li>
              <li>
                <a href="http://www.csszengarden.com/">CSS Zen Garden</a> is a
                testament to the usability of semantic class names.
              </li>
              <li>
                There have been many popular naming conventions over the years
                (<a href="http://smacss.com/"
                  ><abbr title="Scalable and Modular Architecture for CSS"
                    >SMACSS</abbr
                  ></a
                >,
                <a href="http://oocss.org/"
                  ><abbr title="Object Oriented CSS">OOCSS</abbr></a
                >,
                <a href="https://itcss.io/"
                  ><abbr title="Inverted Triangle CSS">ITCSS</abbr></a
                >, etc.) but by far the most popular was
                <a href="https://getbem.com/"
                  ><abbr title="Block, Element, Modifier">BEM</abbr></a
                >.
              </li>
            </ul>
          </section>
          <section>
            <h4>BEM:</h4>
            <ul style="font-size: 0.7em">
              <li>
                Despite showing up over 15 years ago, BEM is still an extremely
                popular approach to CSS.
              </li>
              <li>
                <a href="https://avocss.dev/"
                  ><abbr title="Attribute Value-Objects">AVO</abbr></a
                >, a syntactive varient to BEM, leverages
                <code>data-*</code> attributes and
                <a
                  href="https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors"
                  >attribute selectors</a
                >
                to avoid class name collisions with external libraries.
              </li>
            </ul>
            <pre><code class="css">/* Block */
.button {
  border: 1px solid #D5D5D5;
}

/* Element */
.button__label {
  text-transform: uppercase;
}

/* Modifier */
.button--success {
  border-color: #4A993E;
}</code></pre>
          </section>
          <section>
            <h4>Naming Frameworks:</h4>
            <ul style="font-size: 0.7em">
              <li>
                There are many CSS Frameworks today that leverage some sort of
                naming approach including:
                <a href="https://getbootstrap.com/">Bootstrap</a>,
                <a href="https://bulma.io/">Bulma</a>, and
                <a href="https://materializecss.com/">Materialize</a>
              </li>
            </ul>
            <pre><code class="html">&lt;!-- Bootstrap --&gt;
&lt;div class="container"&gt;
  &lt;div class="row"&gt;
    &lt;div class="col-sm"&gt;
      One of three columns
    &lt;/div&gt;
    &lt;div class="col-sm"&gt;
      One of three columns
    &lt;/div&gt;
    &lt;div class="col-sm"&gt;
      One of three columns
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre>
          </section>
          <section>
            <h4>Naming as an Input:</h4>
            <ul class="iconlist">
              <li class="man good">Easy to maintain; easy to refactor!</li>
              <li class="dx bad">
                The DX blows. Naming things is hard! Requires good linting or
                PRs are a bad time.
              </li>
            </ul>
            <h4>Naming as an Output:</h4>
            <ul class="iconlist">
              <li class="sac good">
                Strict adherence typically results in near-perfect specificity
                handling.<br /><code>:where</code>/<code>:is</code> make
                modifiers even easier. Beware the cascade!
              </li>
              <li class="flex good">Easy to use across an application.</li>
              <li class="flex">
                May conflict with other naming conventions around an
                organization or in 3rd party libraries.
              </li>
              <li class="size">
                It's ok size wise! Class names can get large but Gzip likes
                repetition.
              </li>
            </ul>
          </section>
          <section>
            <h3>Scoped</h3>
            <pre><code class="css">/* CSS Modules */
:global {
  .global-class-name {
    color: green;
  }
}

:local {
  .scoped-class-name {
    color: red;
  }
}</code></pre>
          </section>
          <section>
            <h4>Scoped Tooling: CSS Modules</h4>
            <ul style="font-size: 0.7em">
              <li>
                A
                <a href="https://github.com/css-modules/css-modules"
                  >CSS Module</a
                >
                is a CSS file in which all class names and animation names are
                scoped locally by default.
              </li>
              <li>
                CSS Modules compile to a low-level interchange format called
                ICSS or
                <a href="https://github.com/css-modules/icss"
                  >Interoperable CSS</a
                >, but are written like normal CSS files.
              </li>
              <li>
                Has a <code>composes</code> property to establish class name
                dependencies.
              </li>
            </ul>
            <pre><code class="css">/* Explicitly Global */
:global {
  .global-class-name { color: green; }
}
/* Explicitly Local */
:local {
  .scoped-class-name { color: red; }
}
/* Tooling Default: Either Global or Local */
.default-class-name {
  composes: className from "./style.css";
  color: blue;
}</code></pre>
          </section>
          <section>
            <h4>Scoped Tooling?: Shadow DOM</h4>
            <ul style="font-size: 0.7em">
              <li>
                The
                <a
                  href="https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot"
                  >Shadow DOM</a
                >
                can act as a methodology in and of itself!
              </li>
              <li>Requires JavaScript to run before showing in the browser.</li>
              <li>
                Inheritable properties (including Custom Properties!!!!!!!) are
                inherited.
              </li>
              <li>Can be targeted outside via <code>::part</code>.</li>
            </ul>
            <pre><code class="js">/* Explicitly Global */
const shadowTarget = document.getElementById("target");
const shadow = shadowTarget.attachShadow({ mode: "open" });

// ... attach DOM to shadow ...
</code></pre>
          </section>
          <section>
            <h4>Scoped as an Input:</h4>
            <ul class="iconlist">
              <li class="man good">Easy to maintain; easy to refactor!</li>
              <li class="dx good">The DX is really good.</li>
              <li class="dx">
                Requires build tooling or JavaScript in the browser.
              </li>
            </ul>
            <h4>Scoped as an Output:</h4>
            <ul class="iconlist">
              <li class="sac good">Fantastic specificity handling!</li>
              <li class="flex good">
                Easy to use across an application. Plays well with others!
              </li>
              <li class="size">
                It's not bad size wise! Can be even better than naming
                conventions!
              </li>
            </ul>
          </section>
          <section>
            <h3>Atomic / Functional</h3>
            <div style="display: flex; gap: 0.5em">
              <pre><code class="html">&lt;!-- Atomic w/Atomizer --&gt;
&lt;div class="Bgc(#000) C(#fff)"&gt;
  Lorem ipsum
&lt;/div&gt;</code></pre>
              <pre><code style="overflow: visible;" class="css">/* Utility Classes */        
.show {
  display: block;
}

.hide {
  display: none;
}

.visuallycenter {
  position: relative;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}</code></pre>
            </div>
          </section>
          <section>
            <h4>Atomic Convention:</h4>
            <ul style="font-size: 0.7em">
              <li>Exclusively leverages class selectors and pseudo's.</li>
              <li>
                Single Responsibility Principle meets CSS. Each class does one
                thing and only that thing.
              </li>
              <li>Atomic rules are immutable.</li>
              <li>Near impossible to do well without tooling. So don't!</li>
            </ul>
          </section>
          <section>
            <h4>Atomic Tooling:</h4>
            <ul style="font-size: 0.7em">
              <li>
                Atomic tooling typically generates CSS from markup/files looking
                for specific class patterns.
              </li>
              <li>
                Once the tooling is configured, you write class names, not CSS.
              </li>
              <li>
                <a href="https://acss.io/">Atomizer</a> is a popular
                Framework-less Atomic tool that will generate CSS for you based
                on prefined class names within your markup. Has several
                integrations.
              </li>
            </ul>
            <img
              src="atomic-demo.gif"
              alt="Atomizer Demo"
              style="aspect-ratio: 174/83; height: 30vh"
            />
          </section>
          <section>
            <h4>Atomic Frameworks:</h4>
            <ul style="font-size: 0.7em">
              <li>
                Atomic frameworks combine tooling and pre-defined class names
                together into a single package!
              </li>
              <li>
                <a href="https://tailwindcss.com/">Tailwind CSS</a> is one of
                the most popular CSS frameworks out there and is built on top of
                utility class principles.
              </li>
              <li>
                Tailwind has ranked as the leading CSS framework in Satisfaction
                according to
                <a
                  href="https://2021.stateofcss.com/en-US/technologies/css-frameworks"
                  >State of CSS</a
                >
                poll for the past three years though this poll does not compare
                it to CSS-in-JS tooling.
              </li>
            </ul>
          </section>
          <section>
            <h4>Atomic as an Input:</h4>
            <ul class="iconlist">
              <li class="man good">Easy to maintain; easy to refactor!</li>
              <li class="dx bad">
                Don't write atomic styles. It's hard to maintain manually.
              </li>
              <li class="dx">
                Theming requires extra steps and/or CSS Custom Props
              </li>
            </ul>
            <h4>Atomic as an Output:</h4>
            <ul class="iconlist">
              <li class="sac good">
                Fantastic specificity handling! Everything is (0,X,0)
              </li>

              <li class="flex good">Can coincide with 3rd party libraries.</li>
              <li class="flex bad">
                Hard to share atomically styled components across an
                organization unless they too are doing atomic and/or you can
                leverage cascade layers.
              </li>
              <li class="size good">
                Amazing!!! Far and away the best output for size!
              </li>
            </ul>
          </section>
        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script src="node_modules/reveal-css-snippet/css-snippet.js"></script>
    <script>
      Reveal.initialize({
        hash: true,
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
      });

      const elements = [
        {
          el: document.getElementById("specificity"),
          cssValue: `#example {
	color: gold;
}

.example {
	color: purple;
}`,
        },
        {
          el: document.getElementById("specificity2"),
          cssValue: `div:is(#example2) {
	color: green;
}

div:where(#example2) {
	color: gold;
}

#example2 {
	color: purple;
}`,
        },
        {
          el: document.getElementById("specificity3"),
          cssValue: `.example3 {
	color: purple;
}

@layer {
  #example3 {
	  color: gold;
  }
}`,
        },
        {
          el: document.getElementById("specificity4"),
          cssValue: `#example4 {
	color: gold;
}

.example4 {
	color: purple;
}

::part(example4) {
	color: green;
}`,
        },
      ];

      elements.forEach(({ el, cssValue }) => {
        el.insertBefore(
          RevealCSSSnippet({ cssValue }),
          el.querySelector("div")
        );
      });
    </script>
    <script type="module">
      import { calculate } from "./node_modules/specificity/dist/specificity.mjs";

      function onInput(el) {
        const selectorEls = el.querySelectorAll(
          'code > span[class^="hljs-selector"]'
        );

        Array.from(selectorEls).forEach((sel) => {
          if (!sel.children.length && sel.innerText.trim()) {
            const str = sel.innerText;

            const specificity = calculate(str)[0];
            const isWhereOrIs = str == ":is" || str == ":where";

            specificity.specificityArray.forEach((v, i) => {
              sel.dataset["spec" + i] = isWhereOrIs ? 0 : v;
            });
          }
        });
      }

      elements.forEach(({ el }) => {
        el.addEventListener("input", (evt) => onInput(evt.target));
        el.addEventListener("focusout", (evt) => onInput(evt.target));
        onInput(el);
      });

      // Do shadow dom for example 4
      const shadowCnt = document.getElementById("example4");
      const shadowTarget = shadowCnt.parentElement;
      const shadow = shadowTarget.attachShadow({ mode: "open" });

      shadowCnt.setAttribute("part", "example4");
      shadow.appendChild(shadowCnt);
    </script>
  </body>
</html>
